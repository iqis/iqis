---
title: "Is R the best statistical language?"
author: "Siqi Zhang"
date: '2019-04-04'
slug: is-r-the-best-statistical-language
tags:
- R
- Python
categories: []
---

```{r, setup, include = FALSE}
knitr::opts_chunk$set(eval = FALSE)
```

Or, _Why R is better than Python_.

R is the programming language most suitable for working with data. The language is extremely easy to get started with, has minimalistic syntax, and has been inarguably the fastest growing language in the analytics domain for a number of years. R is the only purpose-specific language that [ranks top 10](http://pypl.github.io/PYPL.html) in the PYPL index.  

Personally, R takes about 85% of all my time in front of a code editor, and is the first language that I felt have mastered. During the past two or three years, I have accomplished more with R than with any other language combined. 

Python, while making advances in nearly all fronts of computing, with an edge in deep learning, has in recent years risen as a strong contender in R's arena. Despite heightened public enthusiasm, however, it is not very likely to supplant R's dominance in data science as the go-to language. 

The key factor comes from usability. Python does not serve the user nearly as well as R does. In stern and stark contrast with Python's reputation, beginners of either language often find Python's syntax convoluted, its program verbose, and usage inconvenient. This is not on the fault of Python _per se_. R is far more superior in usability because it is built from the ground up as an interactive language.

This article is going to be an in-detail analysis on R's syntactical features, comparing with that of Python side-by-side. 

Some people arrive at "Python is better than R." via "Python is a powerful, general purpose language", and "R is a domain-specific language". 

The statements are correct, but the conclusion is not. What's wrong?
According to the (Rule of the Least Power)[https://www.w3.org/2001/tag/doc/leastPower.html], a princple codified by the W3C:

> [Programming] in less powerful languages increases the flexibility with which information can be reused: the less powerful the language, the more you can do with the data stored in that language.


It is reasonable to say that, __R is as better than Python as it is less powerful__. 


To quote a great computer scientist: 

> A programming language is low level when its programs require attention to the irrelevant.
> 
> --- Alan Perlis

Therefore, with respect to data science, Python is a lower-level programming language, and is most suitable for use beneath the friendly user interface laid out by R. Specifically, most deep learning capabilities in Python, such as _Keras_, _TensorFlow_, all have mature adaptations in R. 

For most people, a familarity with Python will only be useful for reading and porting existing codebases.

Using Python to approach analytical issues is like making sculpture with a chainsaw. 

<img src = "https://upload.wikimedia.org/wikipedia/commons/8/8e/ChainsawartinBrienz.JPG", style = "max-width: 30%; padding: 20px 20px 20px 20px"/>

It is possible to achieve great results, however only by way of struggling with the tool.

### R has a mature ecosystem
Rkward, Rcommander, Jamovi, and else.


Python does not have a sophisticated IDE or text editor for analytics. 
Wrangler from yhat seems to be stagnant in development
Spyder is ...


Jupyter is all about the "Py" in its name. I rarely see Julia or R user use the notebook. 


It is ... to remember that Python is a language with a record of hard fork between version 2 and 3, aftermath still evident of this day. Nobody has counted the time when some Python novice trodded onto a v.2-only solution on StackOverflow, and pulled his hair in agony.



### R is simple
R is a very simple language, expecially in its syntax.  
Thanks to its functional programming root, in R, everything that exists is an object, and everything that happens is a function. This characteristic is not, from any point of view, unique to R; but R syntax makes it quite obvious. 

Everything that happens is a function.

To attach a library: 
```{r}
library(caret)
#or
require(caret)
```
To return a value from a funciton:
```{r}
function(){
        return(1)
}
```

There are some that adopts C-like characteristics, purposed for imperative programming. 
```{r}
for (i in 1:5){
        print(i)
}

if (TRUE){
        print("yes")
} else {
print("no")
}
```

The above can be easily re-written with keywords quoted with ``, in a purely functional style, as:

```{r}
`for`(i, 1:5, print(i))
`if`(TRUE, print("yes"), print("no"))
```
There are also special operators, such as assignment `<-` and subset`[`/`[[`/`$`, which can be re-written the same way:
```{r}
# Assign an object
a <- 1
# is equivalent to:
`<-`(a, 1)

# Subset an object
profile <- list(name = "mike", gender = "male", id = 7)

profile[1]
profile["name"]
profile[["gender"]]
profile$id
# are equivalent to:
`[`(profile, 1)
`[`(profile, "name")
`[[`(profile, "gender")
`$`(profile, id)
```


In Python, 
in the follwing code example, keyword `import` does invoke underlying functions. But it is very obfuscated.  
```{python}
import numpy as np

```
It is not unusual to see beginner getting caught up in the syntax, which is reasonably complex. 

It's harder to get started with, and you'll find yourself hitting the ceiling pretty fast. 


### Data Types
- `vector`
  - Homogeneous, flat, 1D
- `list`
  - Heterogeneous, recursive, 1D
- `matrix`,
  - Vector of vectors, 2D
- `data.frame`
  - List of vectors or lists, 2D 
- `array`
  - Homogeneous, 1 to Inf dimensions

Perl has `array`, `hash`
Python has ` 

### Namespace
R has a convenient namespace and symbol resolution scheme. It is very similar to [that of Perl](https://perlmaven.com/namespaces-and-packages), and [that of Ruby](https://rubymonk.com/learning/books/1-ruby-primer/chapters/35-modules/lessons/80-modules-as-namespaces) and uses `::` to qualify symbols within a namespace. 

In R, a namespace can only be defined by a package, and it is not likely possible to have nested namespaces.

One would use `library()` or `reuiqre()` to attach a namespace (from a package) to the search path. Once a namespace is attached to the search path, all consequent invokations of a symbol will be evaluated throught the namesapce, until it is detached with `detach()`. 

`environment`s and `list`s can also be used in the place of a namespace when evaluating a symbol, with `attach()` and `with()`.


A namespace searth path determines the search order for a symbol(name). The search will begin at the most recently attached namespace.
there is no need to qualify a symbol. 


Python follows Java style to use the `.` notation. It is mandatory to qualify a symbol. 

Otherwise, scoping rules are similar between the two languages. 

This makes Python scripts more verbose, and breaks the analyst's rythem when rapidly executing exploratory tasks. 

```{python}
import random as r
print(dir())
```


```{python}
print(dir())
```

```{python}
from random import *
print(dir())
```






### R is consistent
Becuse R has simple syntactical features, 




### Solutions in R are Apparent




All the above coming together, makes R easy to learn, and easy to share.


### Data Structures

On the otherhand, Python has redundant data structure.

#### Store homogenic elements in a collection
```{r}
c(1,2,3)
```
```{python}
[1,2,3]
```

#### Store homogenic elements in a collection, with names
```{r}
c(apple = 1, orange = 2, pear = 3)
```
```{python}
{'apple': 1, 'orange': 2, 'pear': 3}
```

#### Store heterogenic elements in a collection
```{r}
list(1, "foo", TRUE)
```
```{python}
(1, "foo", True)
```

#### Store heterogenic elements in a collection, with names
```{r}
list(apple = 1, orange = "foo", pear = TRUE)
```
```{python}
{'apple': 1, 'orange': "foo", 'pear': True}
```




#### Randomly choose one number from a collection
```{r}
sample(x = 1:5, size = 1)
```
```{python}
import random
print(random.choice(seq = range(5)))
```

#### Randomly choose two numbers from a collection
*R*
```{r}
sample(x = 1:5, size = 2)
```
*Python*
```{python}
import random
print(random.sample(population = range(5), k = 2))
```

#### Generate one number from normal distribution
*R*
```{r}
rnorm(n = 1)
```
*Python*
```{python}
import random
print(random.normalvariate(mu = 0, sigma = 1))

import numpy
print(numpy.random.normal(loc = 0, scale = 1,size = 1))
```
#### Generate two numbers from normal distribution
*R*
```{r}
rnorm(n = 2)
```
*Python*
```{python}
import random 
for x in range(2): 
    print(random.normalvariate(mu = 0, sigma = 1))

import numpy
print(numpy.random.normal(loc = 0, scale = 1,size = 2))
```

#### For-in loop
```{r}
numbers <-  c(1,2,3,4,5)
for (num in numbers){
        print(num)
}
```
```{python}
numbers = [1,2,3,4,5]
for num in numbers:
    print(num)

```





[A Pamphlet against R](http://panicz.github.io/pamphlet/)
In spite of the porovocative title, this pamphlet has only a minute amount of reference to R, and weighs more on discussing the benefits of Scheme, a Lisp dialect.
[R Inferno](https://www.burns-stat.com/pages/Tutor/R_inferno.pdf)
This is _the_ epic on R pecularities and screw-ups. Contrasting with the the tile of the equivalent publication regarding JavaScript, [JavaScript _Garden_](http://bonsaiden.github.io/JavaScript-Garden/), R users' self-hate (or, self-pity) is quite evident. 
